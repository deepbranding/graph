<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morph Animation</title>
    <style>
        body {
            margin: 0;
            background: black;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #container {
            position: absolute;
            width: 100vw;
            height: 80vh; 
            display: flex;
            justify-content: center;
            align-items: center;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.2);
            filter: url(#threshold) blur(0.6px);
            will-change: transform, filter;
        }
        #text1, #text2 {
            position: absolute;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 80pt;
            text-align: center;
            user-select: none;
            will-change: filter, opacity;
        }
        #svgPreloader {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
            visibility: hidden;
        }
    </style>
</head>
<body>
    <div id="container">
        <span id="text1"></span>
        <span id="text2"></span>
    </div>
    
    <svg id="filters">
        <defs>
            <filter id="threshold">
                <feColorMatrix in="SourceGraphic"
                        type="matrix"
                        values="1 0 0 0 0
                                0 1 0 0 0
                                0 0 1 0 0
                                0 0 0 255 -140" />
            </filter>
        </defs>
    </svg>
    
    <!-- Preloader para SVGs -->
    <div id="svgPreloader"></div>
    
    <script>
        // Configuración
        const morphTime = 1;
        const cooldownTime = 0.25;
        
        // Cache de elementos DOM
        const elts = {
            text1: document.getElementById("text1"),
            text2: document.getElementById("text2"),
            preloader: document.getElementById("svgPreloader")
        };
        
        // Lista de SVGs
        const svgPaths = [
            "svgs/Sin título-1-01.svg",
            "svgs/Sin título-1-02.svg",
            "svgs/Sin título-1-03.svg",
            "svgs/Sin título-1-04.svg",
            "svgs/Sin título-1-05.svg",
            "svgs/Sin título-1-06.svg",
            "svgs/Sin título-1-07.svg",
            "svgs/Sin título-1-08.svg",
            "svgs/Sin título-1-09.svg",
            "svgs/Sin título-1-10.svg",
            "svgs/Sin título-1-11.svg",
            "svgs/Sin título-1-12.svg",
            "svgs/Sin título-1-13.svg",
            "svgs/Sin título-1-14.svg",
            "svgs/Sin título-1-15.svg",
            "svgs/Sin título-1-16.svg",
            "svgs/Sin título-1-17.svg",
            "svgs/Sin título-1-18.svg",
            "svgs/Sin título-1-19.svg",
            "svgs/Sin título-1-20.svg",
            "svgs/Sin título-1-21.svg",
            "svgs/Sin título-1-22.svg",
            "svgs/Sin título-1-23.svg",
            "svgs/Sin título-1-24.svg",
            "svgs/Sin título-1-25.svg",
            "svgs/Sin título-1-26.svg",
            "svgs/Sin título-1-27.svg",
            "svgs/Sin título-1-28.svg",
            "svgs/Sin título-1-29.svg",
            "svgs/Sin título-1-30.svg",
            "svgs/Sin título-1-31.svg"
        ];
        
        // Cache para SVGs
        const svgCache = {};
        let svgIndex = svgPaths.length - 1;
        let time = new Date();
        let morph = 0;
        let cooldown = cooldownTime;
        let animationFrameId = null;
        let isInitialized = false;
        
        // Precarga todos los SVGs
        async function preloadSVGs() {
            const promises = svgPaths.map(path => 
                fetch(path)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Error cargando ${path}: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(data => {
                        svgCache[path] = data;
                    })
                    .catch(error => {
                        console.error(error);
                        // Valor por defecto en caso de error
                        svgCache[path] = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="transparent"/></svg>';
                    })
            );
            
            return Promise.all(promises);
        }
        
        // Inserta SVG desde el cache
        function setSVG(element, path) {
            if (svgCache[path]) {
                element.innerHTML = svgCache[path];
            } else {
                console.warn(`SVG ${path} no encontrado en cache`);
            }
        }
        
        function doMorph() {
            morph -= cooldown;
            cooldown = 0;
            let fraction = morph / morphTime;
            
            if (fraction > 1) {
                cooldown = cooldownTime;
                fraction = 1;
            }
            
            setMorph(fraction);
        }
        
        function setMorph(fraction) {
            // Limitar los valores de blur para mejor rendimiento
            const blur1 = Math.min(8 / (1 - fraction) - 8, 100);
            const blur2 = Math.min(8 / fraction - 8, 100);
            
            // Aplicar transformaciones solo cuando hay cambios significativos
            if (fraction < 0.99) {
                elts.text2.style.filter = `blur(${blur2}px)`;
                elts.text2.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;
            }
            
            if (fraction > 0.01) {
                elts.text1.style.filter = `blur(${blur1}px)`;
                elts.text1.style.opacity = `${Math.pow(1 - fraction, 0.4) * 100}%`;
            }
        }
        
        function doCooldown() {
            morph = 0;
            
            // Optimizar aplicando estilos directamente sin cálculos
            elts.text2.style.filter = "";
            elts.text2.style.opacity = "100%";
            elts.text1.style.filter = "";
            elts.text1.style.opacity = "0%";
        }
        
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            const newTime = new Date();
            const shouldIncrementIndex = cooldown > 0;
            const dt = (newTime - time) / 1000;
            time = newTime;
            
            cooldown -= dt;
            
            if (cooldown <= 0) {
                if (shouldIncrementIndex) {
                    svgIndex++;
                    
                    // Usar SVGs desde caché
                    setSVG(elts.text1, svgPaths[svgIndex % svgPaths.length]);
                    setSVG(elts.text2, svgPaths[(svgIndex + 1) % svgPaths.length]);
                }
                
                doMorph();
            } else {
                doCooldown();
            }
        }
        
        // Inicializar la animación
        async function init() {
            if (isInitialized) return;
            
            await preloadSVGs();
            
            // Configurar SVGs iniciales
            setSVG(elts.text1, svgPaths[svgIndex % svgPaths.length]);
            setSVG(elts.text2, svgPaths[(svgIndex + 1) % svgPaths.length]);
            
            // Iniciar animación
            animate();
            isInitialized = true;
        }
        
        // Detener animación cuando la página no está visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            } else if (!animationFrameId && isInitialized) {
                time = new Date(); // Resetear el tiempo
                animate();
            }
        });
        
        // Gestión de memoria cuando la página se cierra
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
        
        // Iniciar después de que la página cargue completamente
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
